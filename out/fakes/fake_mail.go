// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bytes"
	"io"
	"sync"

	mailyak "github.com/domodwyer/mailyak/v3"
	"github.com/pivotal-cf/email-resource/out"
)

type FakeMail struct {
	AddHeaderStub        func(string, string)
	addHeaderMutex       sync.RWMutex
	addHeaderArgsForCall []struct {
		arg1 string
		arg2 string
	}
	AttachStub        func(string, io.Reader)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		arg1 string
		arg2 io.Reader
	}
	BccStub        func(...string)
	bccMutex       sync.RWMutex
	bccArgsForCall []struct {
		arg1 []string
	}
	CcStub        func(...string)
	ccMutex       sync.RWMutex
	ccArgsForCall []struct {
		arg1 []string
	}
	FromStub        func(string)
	fromMutex       sync.RWMutex
	fromArgsForCall []struct {
		arg1 string
	}
	HTMLStub        func() *mailyak.BodyPart
	hTMLMutex       sync.RWMutex
	hTMLArgsForCall []struct {
	}
	hTMLReturns struct {
		result1 *mailyak.BodyPart
	}
	hTMLReturnsOnCall map[int]struct {
		result1 *mailyak.BodyPart
	}
	MimeBufStub        func() (*bytes.Buffer, error)
	mimeBufMutex       sync.RWMutex
	mimeBufArgsForCall []struct {
	}
	mimeBufReturns struct {
		result1 *bytes.Buffer
		result2 error
	}
	mimeBufReturnsOnCall map[int]struct {
		result1 *bytes.Buffer
		result2 error
	}
	PlainStub        func() *mailyak.BodyPart
	plainMutex       sync.RWMutex
	plainArgsForCall []struct {
	}
	plainReturns struct {
		result1 *mailyak.BodyPart
	}
	plainReturnsOnCall map[int]struct {
		result1 *mailyak.BodyPart
	}
	SubjectStub        func(string)
	subjectMutex       sync.RWMutex
	subjectArgsForCall []struct {
		arg1 string
	}
	ToStub        func(...string)
	toMutex       sync.RWMutex
	toArgsForCall []struct {
		arg1 []string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMail) AddHeader(arg1 string, arg2 string) {
	fake.addHeaderMutex.Lock()
	fake.addHeaderArgsForCall = append(fake.addHeaderArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AddHeader", []interface{}{arg1, arg2})
	fake.addHeaderMutex.Unlock()
	if fake.AddHeaderStub != nil {
		fake.AddHeaderStub(arg1, arg2)
	}
}

func (fake *FakeMail) AddHeaderCallCount() int {
	fake.addHeaderMutex.RLock()
	defer fake.addHeaderMutex.RUnlock()
	return len(fake.addHeaderArgsForCall)
}

func (fake *FakeMail) AddHeaderCalls(stub func(string, string)) {
	fake.addHeaderMutex.Lock()
	defer fake.addHeaderMutex.Unlock()
	fake.AddHeaderStub = stub
}

func (fake *FakeMail) AddHeaderArgsForCall(i int) (string, string) {
	fake.addHeaderMutex.RLock()
	defer fake.addHeaderMutex.RUnlock()
	argsForCall := fake.addHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMail) Attach(arg1 string, arg2 io.Reader) {
	fake.attachMutex.Lock()
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		arg1 string
		arg2 io.Reader
	}{arg1, arg2})
	fake.recordInvocation("Attach", []interface{}{arg1, arg2})
	fake.attachMutex.Unlock()
	if fake.AttachStub != nil {
		fake.AttachStub(arg1, arg2)
	}
}

func (fake *FakeMail) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeMail) AttachCalls(stub func(string, io.Reader)) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.AttachStub = stub
}

func (fake *FakeMail) AttachArgsForCall(i int) (string, io.Reader) {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	argsForCall := fake.attachArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMail) Bcc(arg1 ...string) {
	fake.bccMutex.Lock()
	fake.bccArgsForCall = append(fake.bccArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.recordInvocation("Bcc", []interface{}{arg1})
	fake.bccMutex.Unlock()
	if fake.BccStub != nil {
		fake.BccStub(arg1...)
	}
}

func (fake *FakeMail) BccCallCount() int {
	fake.bccMutex.RLock()
	defer fake.bccMutex.RUnlock()
	return len(fake.bccArgsForCall)
}

func (fake *FakeMail) BccCalls(stub func(...string)) {
	fake.bccMutex.Lock()
	defer fake.bccMutex.Unlock()
	fake.BccStub = stub
}

func (fake *FakeMail) BccArgsForCall(i int) []string {
	fake.bccMutex.RLock()
	defer fake.bccMutex.RUnlock()
	argsForCall := fake.bccArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMail) Cc(arg1 ...string) {
	fake.ccMutex.Lock()
	fake.ccArgsForCall = append(fake.ccArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.recordInvocation("Cc", []interface{}{arg1})
	fake.ccMutex.Unlock()
	if fake.CcStub != nil {
		fake.CcStub(arg1...)
	}
}

func (fake *FakeMail) CcCallCount() int {
	fake.ccMutex.RLock()
	defer fake.ccMutex.RUnlock()
	return len(fake.ccArgsForCall)
}

func (fake *FakeMail) CcCalls(stub func(...string)) {
	fake.ccMutex.Lock()
	defer fake.ccMutex.Unlock()
	fake.CcStub = stub
}

func (fake *FakeMail) CcArgsForCall(i int) []string {
	fake.ccMutex.RLock()
	defer fake.ccMutex.RUnlock()
	argsForCall := fake.ccArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMail) From(arg1 string) {
	fake.fromMutex.Lock()
	fake.fromArgsForCall = append(fake.fromArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("From", []interface{}{arg1})
	fake.fromMutex.Unlock()
	if fake.FromStub != nil {
		fake.FromStub(arg1)
	}
}

func (fake *FakeMail) FromCallCount() int {
	fake.fromMutex.RLock()
	defer fake.fromMutex.RUnlock()
	return len(fake.fromArgsForCall)
}

func (fake *FakeMail) FromCalls(stub func(string)) {
	fake.fromMutex.Lock()
	defer fake.fromMutex.Unlock()
	fake.FromStub = stub
}

func (fake *FakeMail) FromArgsForCall(i int) string {
	fake.fromMutex.RLock()
	defer fake.fromMutex.RUnlock()
	argsForCall := fake.fromArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMail) HTML() *mailyak.BodyPart {
	fake.hTMLMutex.Lock()
	ret, specificReturn := fake.hTMLReturnsOnCall[len(fake.hTMLArgsForCall)]
	fake.hTMLArgsForCall = append(fake.hTMLArgsForCall, struct {
	}{})
	fake.recordInvocation("HTML", []interface{}{})
	fake.hTMLMutex.Unlock()
	if fake.HTMLStub != nil {
		return fake.HTMLStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hTMLReturns
	return fakeReturns.result1
}

func (fake *FakeMail) HTMLCallCount() int {
	fake.hTMLMutex.RLock()
	defer fake.hTMLMutex.RUnlock()
	return len(fake.hTMLArgsForCall)
}

func (fake *FakeMail) HTMLCalls(stub func() *mailyak.BodyPart) {
	fake.hTMLMutex.Lock()
	defer fake.hTMLMutex.Unlock()
	fake.HTMLStub = stub
}

func (fake *FakeMail) HTMLReturns(result1 *mailyak.BodyPart) {
	fake.hTMLMutex.Lock()
	defer fake.hTMLMutex.Unlock()
	fake.HTMLStub = nil
	fake.hTMLReturns = struct {
		result1 *mailyak.BodyPart
	}{result1}
}

func (fake *FakeMail) HTMLReturnsOnCall(i int, result1 *mailyak.BodyPart) {
	fake.hTMLMutex.Lock()
	defer fake.hTMLMutex.Unlock()
	fake.HTMLStub = nil
	if fake.hTMLReturnsOnCall == nil {
		fake.hTMLReturnsOnCall = make(map[int]struct {
			result1 *mailyak.BodyPart
		})
	}
	fake.hTMLReturnsOnCall[i] = struct {
		result1 *mailyak.BodyPart
	}{result1}
}

func (fake *FakeMail) MimeBuf() (*bytes.Buffer, error) {
	fake.mimeBufMutex.Lock()
	ret, specificReturn := fake.mimeBufReturnsOnCall[len(fake.mimeBufArgsForCall)]
	fake.mimeBufArgsForCall = append(fake.mimeBufArgsForCall, struct {
	}{})
	fake.recordInvocation("MimeBuf", []interface{}{})
	fake.mimeBufMutex.Unlock()
	if fake.MimeBufStub != nil {
		return fake.MimeBufStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.mimeBufReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeMail) MimeBufCallCount() int {
	fake.mimeBufMutex.RLock()
	defer fake.mimeBufMutex.RUnlock()
	return len(fake.mimeBufArgsForCall)
}

func (fake *FakeMail) MimeBufCalls(stub func() (*bytes.Buffer, error)) {
	fake.mimeBufMutex.Lock()
	defer fake.mimeBufMutex.Unlock()
	fake.MimeBufStub = stub
}

func (fake *FakeMail) MimeBufReturns(result1 *bytes.Buffer, result2 error) {
	fake.mimeBufMutex.Lock()
	defer fake.mimeBufMutex.Unlock()
	fake.MimeBufStub = nil
	fake.mimeBufReturns = struct {
		result1 *bytes.Buffer
		result2 error
	}{result1, result2}
}

func (fake *FakeMail) MimeBufReturnsOnCall(i int, result1 *bytes.Buffer, result2 error) {
	fake.mimeBufMutex.Lock()
	defer fake.mimeBufMutex.Unlock()
	fake.MimeBufStub = nil
	if fake.mimeBufReturnsOnCall == nil {
		fake.mimeBufReturnsOnCall = make(map[int]struct {
			result1 *bytes.Buffer
			result2 error
		})
	}
	fake.mimeBufReturnsOnCall[i] = struct {
		result1 *bytes.Buffer
		result2 error
	}{result1, result2}
}

func (fake *FakeMail) Plain() *mailyak.BodyPart {
	fake.plainMutex.Lock()
	ret, specificReturn := fake.plainReturnsOnCall[len(fake.plainArgsForCall)]
	fake.plainArgsForCall = append(fake.plainArgsForCall, struct {
	}{})
	fake.recordInvocation("Plain", []interface{}{})
	fake.plainMutex.Unlock()
	if fake.PlainStub != nil {
		return fake.PlainStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.plainReturns
	return fakeReturns.result1
}

func (fake *FakeMail) PlainCallCount() int {
	fake.plainMutex.RLock()
	defer fake.plainMutex.RUnlock()
	return len(fake.plainArgsForCall)
}

func (fake *FakeMail) PlainCalls(stub func() *mailyak.BodyPart) {
	fake.plainMutex.Lock()
	defer fake.plainMutex.Unlock()
	fake.PlainStub = stub
}

func (fake *FakeMail) PlainReturns(result1 *mailyak.BodyPart) {
	fake.plainMutex.Lock()
	defer fake.plainMutex.Unlock()
	fake.PlainStub = nil
	fake.plainReturns = struct {
		result1 *mailyak.BodyPart
	}{result1}
}

func (fake *FakeMail) PlainReturnsOnCall(i int, result1 *mailyak.BodyPart) {
	fake.plainMutex.Lock()
	defer fake.plainMutex.Unlock()
	fake.PlainStub = nil
	if fake.plainReturnsOnCall == nil {
		fake.plainReturnsOnCall = make(map[int]struct {
			result1 *mailyak.BodyPart
		})
	}
	fake.plainReturnsOnCall[i] = struct {
		result1 *mailyak.BodyPart
	}{result1}
}

func (fake *FakeMail) Subject(arg1 string) {
	fake.subjectMutex.Lock()
	fake.subjectArgsForCall = append(fake.subjectArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Subject", []interface{}{arg1})
	fake.subjectMutex.Unlock()
	if fake.SubjectStub != nil {
		fake.SubjectStub(arg1)
	}
}

func (fake *FakeMail) SubjectCallCount() int {
	fake.subjectMutex.RLock()
	defer fake.subjectMutex.RUnlock()
	return len(fake.subjectArgsForCall)
}

func (fake *FakeMail) SubjectCalls(stub func(string)) {
	fake.subjectMutex.Lock()
	defer fake.subjectMutex.Unlock()
	fake.SubjectStub = stub
}

func (fake *FakeMail) SubjectArgsForCall(i int) string {
	fake.subjectMutex.RLock()
	defer fake.subjectMutex.RUnlock()
	argsForCall := fake.subjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMail) To(arg1 ...string) {
	fake.toMutex.Lock()
	fake.toArgsForCall = append(fake.toArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.recordInvocation("To", []interface{}{arg1})
	fake.toMutex.Unlock()
	if fake.ToStub != nil {
		fake.ToStub(arg1...)
	}
}

func (fake *FakeMail) ToCallCount() int {
	fake.toMutex.RLock()
	defer fake.toMutex.RUnlock()
	return len(fake.toArgsForCall)
}

func (fake *FakeMail) ToCalls(stub func(...string)) {
	fake.toMutex.Lock()
	defer fake.toMutex.Unlock()
	fake.ToStub = stub
}

func (fake *FakeMail) ToArgsForCall(i int) []string {
	fake.toMutex.RLock()
	defer fake.toMutex.RUnlock()
	argsForCall := fake.toArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeMail) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addHeaderMutex.RLock()
	defer fake.addHeaderMutex.RUnlock()
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	fake.bccMutex.RLock()
	defer fake.bccMutex.RUnlock()
	fake.ccMutex.RLock()
	defer fake.ccMutex.RUnlock()
	fake.fromMutex.RLock()
	defer fake.fromMutex.RUnlock()
	fake.hTMLMutex.RLock()
	defer fake.hTMLMutex.RUnlock()
	fake.mimeBufMutex.RLock()
	defer fake.mimeBufMutex.RUnlock()
	fake.plainMutex.RLock()
	defer fake.plainMutex.RUnlock()
	fake.subjectMutex.RLock()
	defer fake.subjectMutex.RUnlock()
	fake.toMutex.RLock()
	defer fake.toMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMail) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ out.Mail = new(FakeMail)
